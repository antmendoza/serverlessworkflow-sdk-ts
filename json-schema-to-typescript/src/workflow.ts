/* tslint:disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type Startdef =
  | string
  | {
      /**
       * Name of the starting workflow state
       */
      stateName: string;
      /**
       * Define the time/repeating intervals or cron at which workflow instances should be automatically started.
       */
      schedule:
        | string
        | {
            [k: string]: unknown;
          };
      [k: string]: unknown;
    };
/**
 * This state is used to wait for events from event sources, then consumes them and invoke one or more actions to run in sequence or parallel
 */
export type EventState =
  | {
      [k: string]: unknown;
    }
  | {
      [k: string]: unknown;
    }
  | {
      [k: string]: unknown;
    };
export type SwitchState = Databasedswitch | Eventbasedswitch;

type Functions = | string
    | {
    /**
     * Unique function name
     */
    name: string;
    /**
     * If type is `rest`, <path_to_openapi_definition>#<operation_id>. If type is `rpc`, <path_to_grpc_proto_file>#<service_name>#<service_method>. If type is `expression`, defines the workflow expression.
     */
    operation: string;
    /**
     * Defines the function type. Is either `rest`, `rpc` or `expression`. Default is `rest`
     */
    type?: "rest" | "rpc" | "expression";
    [k: string]: unknown;
}[];

/**
 * Serverless Workflow specification - workflow schema
 */
export interface Workflow {
  /**
   * Workflow unique identifier
   */
  id: string;
  /**
   * Workflow name
   */
  name: string;
  /**
   * Workflow description
   */
  description?: string;
  /**
   * Workflow version
   */
  version: string;
  start: Startdef;
  /**
   * Serverless Workflow schema version
   */
  schemaVersion?: string;
  /**
   * Identifies the expression language used for workflow expressions. Default is 'jq'
   */
  expressionLang?: string;
  execTimeout?: Exectimeout;
  /**
   * If 'true', workflow instances is not terminated when there are no active execution paths. Instance can be terminated via 'terminate end definition' or reaching defined 'execTimeout'
   */
  keepActive?: boolean;
  /**
   * Metadata information
   */
  metadata?: {
    [k: string]: string;
  };
  events?:
    | string
    | {
        /**
         * Unique event name
         */
        name?: string;
        /**
         * CloudEvent source
         */
        source?: string;
        /**
         * CloudEvent type
         */
        type?: string;
        /**
         * Defines the CloudEvent as either 'consumed' or 'produced' by the workflow. Default is 'consumed'
         */
        kind?: "consumed" | "produced";
        /**
         * CloudEvent correlation definitions
         */
        correlation?: {
          /**
           * CloudEvent Extension Context Attribute name
           */
          contextAttributeName: string;
          /**
           * CloudEvent Extension Context Attribute value
           */
          contextAttributeValue?: string;
          [k: string]: unknown;
        }[];
        /**
         * Metadata information
         */
        metadata?: {
          [k: string]: string;
        };
        [k: string]: unknown;
      }[];
  functions?:
    Functions;
  retries?:
    | string
    | {
        /**
         * Unique retry strategy name
         */
        name: string;
        /**
         * Time delay between retry attempts (ISO 8601 duration format)
         */
        delay?: string;
        /**
         * Maximum time delay between retry attempts (ISO 8601 duration format)
         */
        maxDelay?: string;
        /**
         * Static value by which the delay increases during each attempt (ISO 8601 time format)
         */
        increment?: string;
        /**
         * Numeric value, if specified the delay between retries is multiplied by this value.
         */
        multiplier?: number | string;
        /**
         * Maximum number of retry attempts.
         */
        maxAttempts: number | string;
        /**
         * If float type, maximum amount of random time added or subtracted from the delay between each retry relative to total delay (between 0 and 1). If string type, absolute maximum amount of random time added or subtracted from the delay between each retry (ISO 8601 duration format)
         */
        jitter?: number | string;
        [k: string]: unknown;
      }[];
  /**
   * State definitions
   */
  states: [
    (
      | DelayState
      | EventState
      | OperationState
      | ParallelState
      | SwitchState
      | SubFlowState
      | InjectState
      | ForEachState
      | CallbackState
    ),
    ...(
      | DelayState
      | EventState
      | OperationState
      | ParallelState
      | SwitchState
      | SubFlowState
      | InjectState
      | ForEachState
      | CallbackState
    )[]
  ];
  [k: string]: unknown;
}
export interface Exectimeout {
  /**
   * Timeout duration (ISO 8601 duration format)
   */
  duration: string;
  /**
   * If `false`, workflow instance is allowed to finish current execution. If `true`, current workflow execution is abrupted.
   */
  interrupt?: boolean;
  /**
   * Name of a workflow state to be executed before workflow instance is terminated
   */
  runBefore?: string;
  [k: string]: unknown;
}
/**
 * Causes the workflow execution to delay for a specified duration
 */
export interface DelayState {
  /**
   * Unique State id
   */
  id?: string;
  /**
   * State name
   */
  name?: string;
  /**
   * State type
   */
  type?: string;
  /**
   * State end definition
   */
  end?:
    | boolean
    | {
        /**
         * If true, completes all execution flows in the given workflow instance
         */
        terminate?: boolean;
        /**
         * Defines events that should be produced
         */
        produceEvents?: {
          /**
           * References a name of a defined event
           */
          eventRef?: string;
          /**
           * If String, expression which selects parts of the states data output to become the data of the produced event. If object a custom object to become the data of produced event.
           */
          data?:
            | string
            | {
                [k: string]: unknown;
              };
          /**
           * Add additional event extension context attributes
           */
          contextAttributes?: {
            [k: string]: string;
          };
          [k: string]: unknown;
        }[];
        /**
         * If set to true, triggers workflow compensation. Default is false
         */
        compensate?: boolean;
        [k: string]: unknown;
      };
  /**
   * State data filter
   */
  stateDataFilter?: {
    /**
     * Workflow expression to filter the state data input
     */
    input?: string;
    /**
     * Workflow expression that filters the state data output
     */
    output?: string;
    [k: string]: unknown;
  };
  /**
   * Amount of time (ISO 8601 format) to delay
   */
  timeDelay?: string;
  /**
   * States error handling and retries definitions
   */
  onErrors?: (
    | {
        [k: string]: unknown;
      }
    | {
        [k: string]: unknown;
      }
  )[];
  /**
   * Next transition of the workflow after the time delay
   */
  transition?:
    | string
    | {
        /**
         * Name of state to transition to
         */
        nextState: string;
        /**
         * Array of events to be produced before the transition happens
         */
        produceEvents?: {
          /**
           * References a name of a defined event
           */
          eventRef?: string;
          /**
           * If String, expression which selects parts of the states data output to become the data of the produced event. If object a custom object to become the data of produced event.
           */
          data?:
            | string
            | {
                [k: string]: unknown;
              };
          /**
           * Add additional event extension context attributes
           */
          contextAttributes?: {
            [k: string]: string;
          };
          [k: string]: unknown;
        }[];
        /**
         * If set to true, triggers workflow compensation when before this transition is taken. Default is false
         */
        compensate?: boolean;
        [k: string]: unknown;
      };
  /**
   * Unique Name of a workflow state which is responsible for compensation of this state
   */
  compensatedBy?: string;
  /**
   * If true, this state is used to compensate another state. Default is false
   */
  usedForCompensation?: boolean;
  /**
   * Metadata information
   */
  metadata?: {
    [k: string]: string;
  };
  [k: string]: unknown;
}
/**
 * Defines actions be performed. Does not wait for incoming events
 */
export interface OperationState {
  /**
   * Unique State id
   */
  id?: string;
  /**
   * State name
   */
  name?: string;
  /**
   * State type
   */
  type?: string;
  /**
   * State end definition
   */
  end?:
    | boolean
    | {
        /**
         * If true, completes all execution flows in the given workflow instance
         */
        terminate?: boolean;
        /**
         * Defines events that should be produced
         */
        produceEvents?: {
          /**
           * References a name of a defined event
           */
          eventRef?: string;
          /**
           * If String, expression which selects parts of the states data output to become the data of the produced event. If object a custom object to become the data of produced event.
           */
          data?:
            | string
            | {
                [k: string]: unknown;
              };
          /**
           * Add additional event extension context attributes
           */
          contextAttributes?: {
            [k: string]: string;
          };
          [k: string]: unknown;
        }[];
        /**
         * If set to true, triggers workflow compensation. Default is false
         */
        compensate?: boolean;
        [k: string]: unknown;
      };
  /**
   * State data filter
   */
  stateDataFilter?: {
    /**
     * Workflow expression to filter the state data input
     */
    input?: string;
    /**
     * Workflow expression that filters the state data output
     */
    output?: string;
    [k: string]: unknown;
  };
  /**
   * Specifies whether actions are performed in sequence or in parallel
   */
  actionMode?: "sequential" | "parallel";
  /**
   * Actions to be performed
   */
  actions?: (
    | {
        [k: string]: unknown;
      }
    | {
        [k: string]: unknown;
      }
  )[];
  /**
   * States error handling and retries definitions
   */
  onErrors?: (
    | {
        [k: string]: unknown;
      }
    | {
        [k: string]: unknown;
      }
  )[];
  /**
   * Next transition of the workflow after all the actions have been performed
   */
  transition?:
    | string
    | {
        /**
         * Name of state to transition to
         */
        nextState: string;
        /**
         * Array of events to be produced before the transition happens
         */
        produceEvents?: {
          /**
           * References a name of a defined event
           */
          eventRef?: string;
          /**
           * If String, expression which selects parts of the states data output to become the data of the produced event. If object a custom object to become the data of produced event.
           */
          data?:
            | string
            | {
                [k: string]: unknown;
              };
          /**
           * Add additional event extension context attributes
           */
          contextAttributes?: {
            [k: string]: string;
          };
          [k: string]: unknown;
        }[];
        /**
         * If set to true, triggers workflow compensation when before this transition is taken. Default is false
         */
        compensate?: boolean;
        [k: string]: unknown;
      };
  /**
   * Unique Name of a workflow state which is responsible for compensation of this state
   */
  compensatedBy?: string;
  /**
   * If true, this state is used to compensate another state. Default is false
   */
  usedForCompensation?: boolean;
  /**
   * Metadata information
   */
  metadata?: {
    [k: string]: string;
  };
  [k: string]: unknown;
}
/**
 * Consists of a number of states that are executed in parallel
 */
export interface ParallelState {
  /**
   * Unique State id
   */
  id?: string;
  /**
   * State name
   */
  name?: string;
  /**
   * State type
   */
  type?: string;
  /**
   * State end definition
   */
  end?:
    | boolean
    | {
        /**
         * If true, completes all execution flows in the given workflow instance
         */
        terminate?: boolean;
        /**
         * Defines events that should be produced
         */
        produceEvents?: {
          /**
           * References a name of a defined event
           */
          eventRef?: string;
          /**
           * If String, expression which selects parts of the states data output to become the data of the produced event. If object a custom object to become the data of produced event.
           */
          data?:
            | string
            | {
                [k: string]: unknown;
              };
          /**
           * Add additional event extension context attributes
           */
          contextAttributes?: {
            [k: string]: string;
          };
          [k: string]: unknown;
        }[];
        /**
         * If set to true, triggers workflow compensation. Default is false
         */
        compensate?: boolean;
        [k: string]: unknown;
      };
  /**
   * State data filter
   */
  stateDataFilter?: {
    /**
     * Workflow expression to filter the state data input
     */
    input?: string;
    /**
     * Workflow expression that filters the state data output
     */
    output?: string;
    [k: string]: unknown;
  };
  /**
   * Branch Definitions
   */
  branches?: (
    | {
        [k: string]: unknown;
      }
    | {
        [k: string]: unknown;
      }
  )[];
  /**
   * Option types on how to complete branch execution.
   */
  completionType?: "and" | "xor" | "n_of_m";
  /**
   * Used when completionType is set to 'n_of_m' to specify the 'N' value
   */
  n?: number | string;
  /**
   * States error handling and retries definitions
   */
  onErrors?: (
    | {
        [k: string]: unknown;
      }
    | {
        [k: string]: unknown;
      }
  )[];
  /**
   * Next transition of the workflow after all branches have completed execution
   */
  transition?:
    | string
    | {
        /**
         * Name of state to transition to
         */
        nextState: string;
        /**
         * Array of events to be produced before the transition happens
         */
        produceEvents?: {
          /**
           * References a name of a defined event
           */
          eventRef?: string;
          /**
           * If String, expression which selects parts of the states data output to become the data of the produced event. If object a custom object to become the data of produced event.
           */
          data?:
            | string
            | {
                [k: string]: unknown;
              };
          /**
           * Add additional event extension context attributes
           */
          contextAttributes?: {
            [k: string]: string;
          };
          [k: string]: unknown;
        }[];
        /**
         * If set to true, triggers workflow compensation when before this transition is taken. Default is false
         */
        compensate?: boolean;
        [k: string]: unknown;
      };
  /**
   * Unique Name of a workflow state which is responsible for compensation of this state
   */
  compensatedBy?: string;
  /**
   * If true, this state is used to compensate another state. Default is false
   */
  usedForCompensation?: boolean;
  /**
   * Metadata information
   */
  metadata?: {
    [k: string]: string;
  };
  [k: string]: unknown;
}
/**
 * Permits transitions to other states based on data conditions
 */
export interface Databasedswitch {
  /**
   * Unique State id
   */
  id?: string;
  /**
   * State name
   */
  name: string;
  /**
   * State type
   */
  type: string;
  /**
   * State data filter
   */
  stateDataFilter?: {
    /**
     * Workflow expression to filter the state data input
     */
    input?: string;
    /**
     * Workflow expression that filters the state data output
     */
    output?: string;
    [k: string]: unknown;
  };
  /**
   * Defines conditions evaluated against state data
   */
  dataConditions: (Transitiondatacondition | Enddatacondition)[];
  /**
   * States error handling and retries definitions
   */
  onErrors?: (
    | {
        [k: string]: unknown;
      }
    | {
        [k: string]: unknown;
      }
  )[];
  /**
   * Default transition of the workflow if there is no matching data conditions. Can include a transition or end definition
   */
  default?:
    | {
        [k: string]: unknown;
      }
    | {
        [k: string]: unknown;
      };
  /**
   * Unique Name of a workflow state which is responsible for compensation of this state
   */
  compensatedBy?: string;
  /**
   * If true, this state is used to compensate another state. Default is false
   */
  usedForCompensation?: boolean;
  /**
   * Metadata information
   */
  metadata?: {
    [k: string]: string;
  };
  [k: string]: unknown;
}
/**
 * Switch state data based condition
 */
export interface Transitiondatacondition {
  /**
   * Data condition name
   */
  name?: string;
  /**
   * Workflow expression evaluated against state data. Must evaluate to true or false
   */
  condition: string;
  /**
   * Workflow transition if condition is evaluated to true
   */
  transition:
    | string
    | {
        /**
         * Name of state to transition to
         */
        nextState: string;
        /**
         * Array of events to be produced before the transition happens
         */
        produceEvents?: {
          /**
           * References a name of a defined event
           */
          eventRef?: string;
          /**
           * If String, expression which selects parts of the states data output to become the data of the produced event. If object a custom object to become the data of produced event.
           */
          data?:
            | string
            | {
                [k: string]: unknown;
              };
          /**
           * Add additional event extension context attributes
           */
          contextAttributes?: {
            [k: string]: string;
          };
          [k: string]: unknown;
        }[];
        /**
         * If set to true, triggers workflow compensation when before this transition is taken. Default is false
         */
        compensate?: boolean;
        [k: string]: unknown;
      };
  [k: string]: unknown;
}
/**
 * Switch state data based condition
 */
export interface Enddatacondition {
  /**
   * Data condition name
   */
  name?: string;
  /**
   * Workflow expression evaluated against state data. Must evaluate to true or false
   */
  condition: string;
  /**
   * Workflow end definition
   */
  end:
    | boolean
    | {
        /**
         * If true, completes all execution flows in the given workflow instance
         */
        terminate?: boolean;
        /**
         * Defines events that should be produced
         */
        produceEvents?: {
          /**
           * References a name of a defined event
           */
          eventRef?: string;
          /**
           * If String, expression which selects parts of the states data output to become the data of the produced event. If object a custom object to become the data of produced event.
           */
          data?:
            | string
            | {
                [k: string]: unknown;
              };
          /**
           * Add additional event extension context attributes
           */
          contextAttributes?: {
            [k: string]: string;
          };
          [k: string]: unknown;
        }[];
        /**
         * If set to true, triggers workflow compensation. Default is false
         */
        compensate?: boolean;
        [k: string]: unknown;
      };
  [k: string]: unknown;
}
/**
 * Permits transitions to other states based on events
 */
export interface Eventbasedswitch {
  /**
   * Unique State id
   */
  id?: string;
  /**
   * State name
   */
  name: string;
  /**
   * State type
   */
  type: string;
  /**
   * State data filter
   */
  stateDataFilter?: {
    /**
     * Workflow expression to filter the state data input
     */
    input?: string;
    /**
     * Workflow expression that filters the state data output
     */
    output?: string;
    [k: string]: unknown;
  };
  /**
   * Defines conditions evaluated against events
   */
  eventConditions: (Transitioneventcondition | Enddeventcondition)[];
  /**
   * States error handling and retries definitions
   */
  onErrors?: (
    | {
        [k: string]: unknown;
      }
    | {
        [k: string]: unknown;
      }
  )[];
  /**
   * If eventConditions is used, defines the time period to wait for events (ISO 8601 format)
   */
  eventTimeout?: string;
  /**
   * Default transition of the workflow if there is no matching data conditions. Can include a transition or end definition
   */
  default?:
    | {
        [k: string]: unknown;
      }
    | {
        [k: string]: unknown;
      };
  /**
   * Unique Name of a workflow state which is responsible for compensation of this state
   */
  compensatedBy?: string;
  /**
   * If true, this state is used to compensate another state. Default is false
   */
  usedForCompensation?: boolean;
  /**
   * Metadata information
   */
  metadata?: {
    [k: string]: string;
  };
  [k: string]: unknown;
}
/**
 * Switch state data event condition
 */
export interface Transitioneventcondition {
  /**
   * Event condition name
   */
  name?: string;
  /**
   * References an unique event name in the defined workflow events
   */
  eventRef: string;
  /**
   * Next transition of the workflow if there is valid matches
   */
  transition:
    | string
    | {
        /**
         * Name of state to transition to
         */
        nextState: string;
        /**
         * Array of events to be produced before the transition happens
         */
        produceEvents?: {
          /**
           * References a name of a defined event
           */
          eventRef?: string;
          /**
           * If String, expression which selects parts of the states data output to become the data of the produced event. If object a custom object to become the data of produced event.
           */
          data?:
            | string
            | {
                [k: string]: unknown;
              };
          /**
           * Add additional event extension context attributes
           */
          contextAttributes?: {
            [k: string]: string;
          };
          [k: string]: unknown;
        }[];
        /**
         * If set to true, triggers workflow compensation when before this transition is taken. Default is false
         */
        compensate?: boolean;
        [k: string]: unknown;
      };
  [k: string]: unknown;
}
/**
 * Switch state data event condition
 */
export interface Enddeventcondition {
  /**
   * Event condition name
   */
  name?: string;
  /**
   * References an unique event name in the defined workflow events
   */
  eventRef: string;
  /**
   * Explicit transition to end
   */
  end:
    | boolean
    | {
        /**
         * If true, completes all execution flows in the given workflow instance
         */
        terminate?: boolean;
        /**
         * Defines events that should be produced
         */
        produceEvents?: {
          /**
           * References a name of a defined event
           */
          eventRef?: string;
          /**
           * If String, expression which selects parts of the states data output to become the data of the produced event. If object a custom object to become the data of produced event.
           */
          data?:
            | string
            | {
                [k: string]: unknown;
              };
          /**
           * Add additional event extension context attributes
           */
          contextAttributes?: {
            [k: string]: string;
          };
          [k: string]: unknown;
        }[];
        /**
         * If set to true, triggers workflow compensation. Default is false
         */
        compensate?: boolean;
        [k: string]: unknown;
      };
  [k: string]: unknown;
}
/**
 * Defines a sub-workflow to be executed
 */
export interface SubFlowState {
  /**
   * Unique state id
   */
  id?: string;
  /**
   * State name
   */
  name?: string;
  /**
   * State type
   */
  type?: string;
  /**
   * State end definition
   */
  end?:
    | boolean
    | {
        /**
         * If true, completes all execution flows in the given workflow instance
         */
        terminate?: boolean;
        /**
         * Defines events that should be produced
         */
        produceEvents?: {
          /**
           * References a name of a defined event
           */
          eventRef?: string;
          /**
           * If String, expression which selects parts of the states data output to become the data of the produced event. If object a custom object to become the data of produced event.
           */
          data?:
            | string
            | {
                [k: string]: unknown;
              };
          /**
           * Add additional event extension context attributes
           */
          contextAttributes?: {
            [k: string]: string;
          };
          [k: string]: unknown;
        }[];
        /**
         * If set to true, triggers workflow compensation. Default is false
         */
        compensate?: boolean;
        [k: string]: unknown;
      };
  /**
   * Workflow execution must wait for sub-workflow to finish before continuing
   */
  waitForCompletion?: boolean;
  /**
   * Sub-workflow unique id
   */
  workflowId?: string;
  /**
   * SubFlow state repeat exec definition
   */
  repeat?: {
    /**
     * Expression evaluated against SubFlow state data. SubFlow will repeat execution as long as this expression is true or until the max property count is reached
     */
    expression?: string;
    /**
     * If true, the expression is evaluated before each repeat execution, if false the expression is evaluated after each repeat execution
     */
    checkBefore?: boolean;
    /**
     * Sets the maximum amount of repeat executions
     */
    max?: number;
    /**
     * If true, repeats executions in a case unhandled errors propagate from the sub-workflow to this state
     */
    continueOnError?: boolean;
    /**
     * List referencing defined consumed workflow events. SubFlow will repeat execution until one of the defined events is consumed, or until the max property count is reached
     */
    stopOnEvents?: [string, ...string[]];
    [k: string]: unknown;
  };
  /**
   * State data filter
   */
  stateDataFilter?: {
    /**
     * Workflow expression to filter the state data input
     */
    input?: string;
    /**
     * Workflow expression that filters the state data output
     */
    output?: string;
    [k: string]: unknown;
  };
  /**
   * States error handling and retries definitions
   */
  onErrors?: (
    | {
        [k: string]: unknown;
      }
    | {
        [k: string]: unknown;
      }
  )[];
  /**
   * Next transition of the workflow after SubFlow has completed execution
   */
  transition?:
    | string
    | {
        /**
         * Name of state to transition to
         */
        nextState: string;
        /**
         * Array of events to be produced before the transition happens
         */
        produceEvents?: {
          /**
           * References a name of a defined event
           */
          eventRef?: string;
          /**
           * If String, expression which selects parts of the states data output to become the data of the produced event. If object a custom object to become the data of produced event.
           */
          data?:
            | string
            | {
                [k: string]: unknown;
              };
          /**
           * Add additional event extension context attributes
           */
          contextAttributes?: {
            [k: string]: string;
          };
          [k: string]: unknown;
        }[];
        /**
         * If set to true, triggers workflow compensation when before this transition is taken. Default is false
         */
        compensate?: boolean;
        [k: string]: unknown;
      };
  /**
   * Unique Name of a workflow state which is responsible for compensation of this state
   */
  compensatedBy?: string;
  /**
   * If true, this state is used to compensate another state. Default is false
   */
  usedForCompensation?: boolean;
  /**
   * Metadata information
   */
  metadata?: {
    [k: string]: string;
  };
  [k: string]: unknown;
}
/**
 * Inject static data into state data. Does not perform any actions
 */
export interface InjectState {
  /**
   * Unique state id
   */
  id?: string;
  /**
   * State name
   */
  name?: string;
  /**
   * State type
   */
  type?: string;
  /**
   * State end definition
   */
  end?:
    | boolean
    | {
        /**
         * If true, completes all execution flows in the given workflow instance
         */
        terminate?: boolean;
        /**
         * Defines events that should be produced
         */
        produceEvents?: {
          /**
           * References a name of a defined event
           */
          eventRef?: string;
          /**
           * If String, expression which selects parts of the states data output to become the data of the produced event. If object a custom object to become the data of produced event.
           */
          data?:
            | string
            | {
                [k: string]: unknown;
              };
          /**
           * Add additional event extension context attributes
           */
          contextAttributes?: {
            [k: string]: string;
          };
          [k: string]: unknown;
        }[];
        /**
         * If set to true, triggers workflow compensation. Default is false
         */
        compensate?: boolean;
        [k: string]: unknown;
      };
  /**
   * JSON object which can be set as states data input and can be manipulated via filters
   */
  data?: {
    [k: string]: unknown;
  };
  /**
   * State data filter
   */
  stateDataFilter?: {
    /**
     * Workflow expression to filter the state data input
     */
    input?: string;
    /**
     * Workflow expression that filters the state data output
     */
    output?: string;
    [k: string]: unknown;
  };
  /**
   * Next transition of the workflow after subflow has completed
   */
  transition?:
    | string
    | {
        /**
         * Name of state to transition to
         */
        nextState: string;
        /**
         * Array of events to be produced before the transition happens
         */
        produceEvents?: {
          /**
           * References a name of a defined event
           */
          eventRef?: string;
          /**
           * If String, expression which selects parts of the states data output to become the data of the produced event. If object a custom object to become the data of produced event.
           */
          data?:
            | string
            | {
                [k: string]: unknown;
              };
          /**
           * Add additional event extension context attributes
           */
          contextAttributes?: {
            [k: string]: string;
          };
          [k: string]: unknown;
        }[];
        /**
         * If set to true, triggers workflow compensation when before this transition is taken. Default is false
         */
        compensate?: boolean;
        [k: string]: unknown;
      };
  /**
   * Unique Name of a workflow state which is responsible for compensation of this state
   */
  compensatedBy?: string;
  /**
   * If true, this state is used to compensate another state. Default is false
   */
  usedForCompensation?: boolean;
  /**
   * Metadata information
   */
  metadata?: {
    [k: string]: string;
  };
  [k: string]: unknown;
}
/**
 * Execute a set of defined actions or workflows for each element of a data array
 */
export interface ForEachState {
  /**
   * Unique State id
   */
  id?: string;
  /**
   * State name
   */
  name?: string;
  /**
   * State type
   */
  type?: string;
  /**
   * State end definition
   */
  end?:
    | boolean
    | {
        /**
         * If true, completes all execution flows in the given workflow instance
         */
        terminate?: boolean;
        /**
         * Defines events that should be produced
         */
        produceEvents?: {
          /**
           * References a name of a defined event
           */
          eventRef?: string;
          /**
           * If String, expression which selects parts of the states data output to become the data of the produced event. If object a custom object to become the data of produced event.
           */
          data?:
            | string
            | {
                [k: string]: unknown;
              };
          /**
           * Add additional event extension context attributes
           */
          contextAttributes?: {
            [k: string]: string;
          };
          [k: string]: unknown;
        }[];
        /**
         * If set to true, triggers workflow compensation. Default is false
         */
        compensate?: boolean;
        [k: string]: unknown;
      };
  /**
   * Workflow expression selecting an array element of the states data
   */
  inputCollection?: string;
  /**
   * Workflow expression specifying an array element of the states data to add the results of each iteration
   */
  outputCollection?: string;
  /**
   * Name of the iteration parameter that can be referenced in actions/workflow. For each parallel iteration, this param should contain an unique element of the inputCollection array
   */
  iterationParam?: string;
  /**
   * Specifies how upper bound on how many iterations may run in parallel
   */
  max?: number | string;
  /**
   * Actions to be executed for each of the elements of inputCollection
   */
  actions?: (
    | {
        [k: string]: unknown;
      }
    | {
        [k: string]: unknown;
      }
  )[];
  /**
   * Unique Id of a workflow to be executed for each of the elements of inputCollection
   */
  workflowId?: string;
  /**
   * State data filter
   */
  stateDataFilter?: {
    /**
     * Workflow expression to filter the state data input
     */
    input?: string;
    /**
     * Workflow expression that filters the state data output
     */
    output?: string;
    [k: string]: unknown;
  };
  /**
   * States error handling and retries definitions
   */
  onErrors?: (
    | {
        [k: string]: unknown;
      }
    | {
        [k: string]: unknown;
      }
  )[];
  /**
   * Next transition of the workflow after state has completed
   */
  transition?:
    | string
    | {
        /**
         * Name of state to transition to
         */
        nextState: string;
        /**
         * Array of events to be produced before the transition happens
         */
        produceEvents?: {
          /**
           * References a name of a defined event
           */
          eventRef?: string;
          /**
           * If String, expression which selects parts of the states data output to become the data of the produced event. If object a custom object to become the data of produced event.
           */
          data?:
            | string
            | {
                [k: string]: unknown;
              };
          /**
           * Add additional event extension context attributes
           */
          contextAttributes?: {
            [k: string]: string;
          };
          [k: string]: unknown;
        }[];
        /**
         * If set to true, triggers workflow compensation when before this transition is taken. Default is false
         */
        compensate?: boolean;
        [k: string]: unknown;
      };
  /**
   * Unique Name of a workflow state which is responsible for compensation of this state
   */
  compensatedBy?: string;
  /**
   * If true, this state is used to compensate another state. Default is false
   */
  usedForCompensation?: boolean;
  /**
   * Metadata information
   */
  metadata?: {
    [k: string]: string;
  };
  [k: string]: unknown;
}
/**
 * This state performs an action, then waits for the callback event that denotes completion of the action
 */
export interface CallbackState {
  /**
   * Unique state id
   */
  id?: string;
  /**
   * State name
   */
  name?: string;
  /**
   * State type
   */
  type?: string;
  /**
   * Defines the action to be executed
   */
  action?:
    | {
        [k: string]: unknown;
      }
    | {
        [k: string]: unknown;
      };
  /**
   * References an unique callback event name in the defined workflow events
   */
  eventRef?: string;
  /**
   * Time period to wait for incoming events (ISO 8601 format)
   */
  timeout?: string;
  /**
   * Event data filter
   */
  eventDataFilter?: {
    /**
     * Workflow expression that filters of the event data (payload)
     */
    data?: string;
    /**
     *  Workflow expression that selects a state data element to which the event payload should be added/merged into. If not specified, denotes, the top-level state data element.
     */
    toStateData?: string;
    [k: string]: unknown;
  };
  /**
   * State data filter
   */
  stateDataFilter?: {
    /**
     * Workflow expression to filter the state data input
     */
    input?: string;
    /**
     * Workflow expression that filters the state data output
     */
    output?: string;
    [k: string]: unknown;
  };
  /**
   * States error handling and retries definitions
   */
  onErrors?: (
    | {
        [k: string]: unknown;
      }
    | {
        [k: string]: unknown;
      }
  )[];
  /**
   * Next transition of the workflow after all the actions have been performed
   */
  transition?:
    | string
    | {
        /**
         * Name of state to transition to
         */
        nextState: string;
        /**
         * Array of events to be produced before the transition happens
         */
        produceEvents?: {
          /**
           * References a name of a defined event
           */
          eventRef?: string;
          /**
           * If String, expression which selects parts of the states data output to become the data of the produced event. If object a custom object to become the data of produced event.
           */
          data?:
            | string
            | {
                [k: string]: unknown;
              };
          /**
           * Add additional event extension context attributes
           */
          contextAttributes?: {
            [k: string]: string;
          };
          [k: string]: unknown;
        }[];
        /**
         * If set to true, triggers workflow compensation when before this transition is taken. Default is false
         */
        compensate?: boolean;
        [k: string]: unknown;
      };
  /**
   * State end definition
   */
  end?:
    | boolean
    | {
        /**
         * If true, completes all execution flows in the given workflow instance
         */
        terminate?: boolean;
        /**
         * Defines events that should be produced
         */
        produceEvents?: {
          /**
           * References a name of a defined event
           */
          eventRef?: string;
          /**
           * If String, expression which selects parts of the states data output to become the data of the produced event. If object a custom object to become the data of produced event.
           */
          data?:
            | string
            | {
                [k: string]: unknown;
              };
          /**
           * Add additional event extension context attributes
           */
          contextAttributes?: {
            [k: string]: string;
          };
          [k: string]: unknown;
        }[];
        /**
         * If set to true, triggers workflow compensation. Default is false
         */
        compensate?: boolean;
        [k: string]: unknown;
      };
  /**
   * Unique Name of a workflow state which is responsible for compensation of this state
   */
  compensatedBy?: string;
  /**
   * If true, this state is used to compensate another state. Default is false
   */
  usedForCompensation?: boolean;
  /**
   * Metadata information
   */
  metadata?: {
    [k: string]: string;
  };
  [k: string]: unknown;
}
